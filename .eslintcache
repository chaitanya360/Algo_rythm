[{"D:\\Web Design\\React - w3schools\\myfirstreact\\src\\index.js":"1","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\reportWebVitals.js":"2","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Sorting\\SortingIndex.js":"3","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Sorting\\MainArea.js":"4","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Sorting\\BarsContainer.jsx":"5","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\AlgoIndex.js":"6","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Searching\\WorkArea.jsx":"7","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Searching\\Array.jsx":"8"},{"size":469,"mtime":1610194044438,"results":"9","hashOfConfig":"10"},{"size":362,"mtime":499162500000,"results":"11","hashOfConfig":"12"},{"size":331,"mtime":1609654891343,"results":"13","hashOfConfig":"10"},{"size":27493,"mtime":1609666568069,"results":"14","hashOfConfig":"10"},{"size":6448,"mtime":1610193142834,"results":"15","hashOfConfig":"10"},{"size":1174,"mtime":1609677954960,"results":"16","hashOfConfig":"10"},{"size":10668,"mtime":1609677877996,"results":"17","hashOfConfig":"10"},{"size":6049,"mtime":1609677854459,"results":"18","hashOfConfig":"10"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},"45vayj",{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"1k8vs2e",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"21"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"21"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"D:\\Web Design\\React - w3schools\\myfirstreact\\src\\index.js",[],["39","40"],"D:\\Web Design\\React - w3schools\\myfirstreact\\src\\reportWebVitals.js",[],["41","42"],"D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Sorting\\SortingIndex.js",[],"D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Sorting\\MainArea.js",["43","44","45","46","47","48","49","50","51"],"import \"./sorting.css\";\r\nimport React, { Component } from \"react\";\r\nimport BarsContainer from \"./BarsContainer.jsx\";\r\nimport { cloneDeep } from \"lodash\";\r\n\r\nclass MainArea extends Component {\r\n  state = {\r\n    bars: [], //width is either width or height depending upon the orientation\r\n    totalBars: 0, //305    125\r\n    barsHeight: 15, //if you want to change this then also change in .css  //2.18  //8.18\r\n    barsWidth: 15, //5  multiplying fact in case of horizontal //1.6\r\n    sortButtonIsPressed: false,\r\n    isSorting: false,\r\n    orientation: [\r\n      \"horizontal\",\r\n      \"flex-end\",\r\n      \"row-reverse\",\r\n      \"flex-end\",\r\n      \"height\",\r\n    ],\r\n    generateButtonisActive: true,\r\n    windoWidth: 0,\r\n    windowHeight: 0,\r\n    sortTypes: [\r\n      { value: \"bubble\", id: 0, customeClass: \"\" },\r\n      { value: \"selection\", id: 0, customeClass: \"\" },\r\n      { value: \"insertion\", id: 0, customeClass: \"\" },\r\n      { value: \"quick\", id: 0, customeClass: \"\" },\r\n      { value: \"heap\", id: 0, customeClass: \"\" },\r\n      { value: \"merge\", id: 0, customeClass: \"\" },\r\n      { value: \"radix\", id: 0, customeClass: \"\" },\r\n      { value: \"shell\", id: 0, customeClass: \"\" },\r\n      { value: \"bucket\", id: 0, customeClass: \"\" },\r\n    ], //\"bubble,selection,insertion,quick,merge,heap,radix,shell,bucket\"   /b-18 s-18 in-\r\n    sortTypeSelected: \"\",\r\n    sortingSpeed: 49, //decreasing this will increase the speed\r\n    isUniform: false, //steady slop\r\n    // barsPosition: \"flex-end\", //\"center\",\"flex-end\"\r\n  };\r\n\r\n  sortIntervalId = 0;\r\n\r\n  barsClone = [];\r\n  i = 0;\r\n  j = 0;\r\n  n = 0;\r\n  key = 0;\r\n  tempBars = [];\r\n  min_idx = 0;\r\n  high = 0;\r\n  low = 0;\r\n\r\n  clone(obj) {\r\n    return cloneDeep(obj);\r\n  }\r\n\r\n  resetEverything = () => {\r\n    this.i = 0;\r\n    this.j = 0;\r\n    this.key = 0;\r\n    this.tempBars = [];\r\n    this.n = 0;\r\n    this.barsClone = [];\r\n    this.min_idx = 0;\r\n    this.setState({ isSorting: false });\r\n  };\r\n\r\n  handleOnGenerateButtonPressed = () => {\r\n    console.log(this.props);\r\n\r\n    if (!this.state.isSorting) {\r\n      clearInterval(this.sortIntervalId);\r\n      this.setState({ isSorting: false });\r\n\r\n      if (this.state.generateButtonisActive) {\r\n        this.resetEverything();\r\n        //generating random widths\r\n        let barsCopy = [];\r\n        let currWidth = 0;\r\n        let currHeight = 0;\r\n        let widthDiff = 400;\r\n        let heightDiff = 120;\r\n        let rightSpace = 30;\r\n        if (this.state.windoWidth < 1050) {\r\n          widthDiff = 40; //for mobile\r\n          heightDiff = 60;\r\n        } else {\r\n          widthDiff = 940;\r\n        }\r\n\r\n        if (this.state.orientation[0] == \"horizontal\") {\r\n          if (this.state.windoWidth < 1050) {\r\n            currWidth = heightDiff - 40;\r\n            heightDiff += heightDiff * 3;\r\n            rightSpace = 0;\r\n          }\r\n          for (\r\n            let i = 0;\r\n            currWidth < this.state.windoWidth - this.state.barsWidth;\r\n            i++\r\n          ) {\r\n            let randomHight = Math.floor(\r\n              Math.random() * (this.state.windowHeight - heightDiff * 1.7) + 1\r\n            );\r\n            currWidth += this.state.barsWidth;\r\n\r\n            barsCopy.push({\r\n              pos: i,\r\n              width: randomHight,\r\n              barsCustomClass: \"\",\r\n            });\r\n          }\r\n        } else {\r\n          if (this.state.windoWidth < 550) currHeight = heightDiff * 2.2;\r\n          else {\r\n            currHeight = 30;\r\n            // widthDiff = 3000;\r\n          }\r\n          for (let i = 0; currHeight < this.state.windowHeight - 152.5; i++) {\r\n            let randomWidth = Math.floor(\r\n              Math.random() * (this.state.windoWidth - widthDiff) + 1\r\n            );\r\n\r\n            currHeight += this.state.barsHeight;\r\n\r\n            barsCopy.push({\r\n              pos: i,\r\n              width: randomWidth,\r\n              barsCustomClass: \"\",\r\n            });\r\n          }\r\n        }\r\n\r\n        // //this.state.totalBars\r\n        // if (!this.state.isHorizontal) {\r\n        //   while (barsWidths.length < this.state.totalBars) {\r\n        //     var r = Math.floor(Math.random() * this.state.totalBars) + 1;\r\n        //     if (\r\n        //       barsWidths.indexOf(r * this.state.barsHeight) === -1 ||\r\n        //       !this.state.isUniform\r\n        //     )\r\n        //       barsWidths.push(r * this.state.barsHeight);\r\n        //   }\r\n        // } else {\r\n        //   while (barsHeights.length < this.state.totalBars) {\r\n        //     //this is for total no. of bars\r\n        //     var r = Math.floor(Math.random() * maxHeight) + 1; //here\r\n        //     if (\r\n        //       barsHeights.indexOf(r * this.state.barsWidth) === -1 ||\r\n        //       !this.state.isUniform\r\n        //     )\r\n        //       barsHeights.push(r * this.state.barsWidth);\r\n        //   }\r\n        // }\r\n\r\n        // let i;\r\n        // for (i = 0; i < this.state.totalBars; i++) {\r\n        //   if (!this.state.isHorizontal)\r\n        //     barsCopy.push({\r\n        //       pos: i,\r\n        //       width: barsWidths[i] - 3,\r\n        //       barsCustomClass: \"\",\r\n        //     });\r\n        //   else\r\n        //     barsCopy.push({\r\n        //       pos: i,\r\n        //       width: barsHeights[i] - 3,\r\n        //       barsCustomClass: \"\",\r\n        //     });\r\n        // }\r\n\r\n        this.setState({ bars: barsCopy, totalBars: barsCopy.length });\r\n\r\n        //initialising the barsClone\r\n\r\n        this.barsClone = this.clone(barsCopy);\r\n      }\r\n    }\r\n  };\r\n\r\n  constructor() {\r\n    super();\r\n    this.updateWindowDimensions();\r\n  }\r\n\r\n  componentDidMount = () => {\r\n    this.updateWindowDimensions();\r\n    window.addEventListener(\"resize\", this.updateWindowDimensions);\r\n  };\r\n\r\n  updateWindowDimensions = () => {\r\n    this.handleOnGenerateButtonPressed();\r\n    if (window.innerWidth < 1000)\r\n      //for mobile setting opening orientation as vertical\r\n      this.setState({\r\n        orientation: [\"vertical\", \"flex-end\", \"column\", \"center\", \"width\"],\r\n      });\r\n    this.setState({\r\n      windoWidth: window.innerWidth,\r\n      windowHeight: window.innerHeight,\r\n    });\r\n  };\r\n\r\n  handleOnSortButtonPressed = () => {\r\n    if (\r\n      !this.state.isSorting &&\r\n      this.state.bars.length > 0 &&\r\n      this.state.bars[0].barsCustomClass == \"\"\r\n    ) {\r\n      this.setState({ bars: this.barsClone, isSorting: true });\r\n      this.setState({ generateButtonisActive: false });\r\n      switch (this.state.sortTypeSelected.value) {\r\n        case \"bubble\":\r\n          this.BubbleSort();\r\n          this.setState({ generateButtonisActive: true, isSorting: false });\r\n          break;\r\n\r\n        case \"insertion\":\r\n          this.insertionSort();\r\n          this.setState({ generateButtonisActive: true, isSorting: false });\r\n          break;\r\n\r\n        case \"selection\":\r\n          this.selectionSort();\r\n          this.setState({ generateButtonisActive: true, isSorting: false });\r\n          break;\r\n\r\n        case \"quick\":\r\n          this.quickSortHandler();\r\n          break;\r\n\r\n        case \"merge\":\r\n          this.mergeSortHandler();\r\n          break;\r\n\r\n        case \"heap\":\r\n          this.heapSortHandler();\r\n          break;\r\n\r\n        case \"radix\":\r\n          this.radixsortHandler();\r\n          break;\r\n\r\n        case \"shell\":\r\n          this.shellSortHandler();\r\n          break;\r\n\r\n        case \"bucket\":\r\n          this.bucketSort();\r\n          this.setState({ bars: this.barsClone });\r\n          this.setState({ generateButtonisActive: true, isSorting: false });\r\n          break;\r\n\r\n        default:\r\n          alert(\"select sort type\");\r\n          this.setState({ isSorting: false });\r\n          break;\r\n      }\r\n    } else {\r\n      if (this.state.isSorting) alert(\"already in process\");\r\n      else alert(\"Generate first,DUde!\");\r\n    }\r\n  };\r\n\r\n  handleOnSortTypeSelected = (type) => {\r\n    if (!this.state.isSorting) {\r\n      this.handleOnGenerateButtonPressed();\r\n      this.setState({\r\n        generateButtonisActive: true,\r\n        isSorting: false,\r\n      });\r\n      if (this.barsClone.length == 0) {\r\n        this.handleOnGenerateButtonPressed();\r\n        this.setState({\r\n          generateButtonisActive: true,\r\n          isSorting: false,\r\n        });\r\n      }\r\n      let sortTypesCopy = cloneDeep(this.state.sortTypes);\r\n      for (let i = 0; i < this.state.sortTypes.length; i++) {\r\n        if (this.state.sortTypes[i] == type)\r\n          sortTypesCopy[i].customeClass = \"sort_button_pressed\";\r\n        else {\r\n          sortTypesCopy[i].customeClass = \"\";\r\n        }\r\n      }\r\n\r\n      this.setState({\r\n        sortTypeSelected: type,\r\n        sortTypes: sortTypesCopy,\r\n        generateButtonisActive: true,\r\n      });\r\n    }\r\n  };\r\n\r\n  handleOnOrientationPressed = () => {\r\n    this.handleOnOrientationPressed2();\r\n  };\r\n\r\n  async handleOnOrientationPressed2() {\r\n    if (this.state.orientation[0] == \"vertical\")\r\n      this.setState({\r\n        orientation: [\r\n          \"horizontal\",\r\n          \"flex-end\",\r\n          \"row-reverse\",\r\n          \"flex-end\",\r\n          \"height\",\r\n        ],\r\n      });\r\n    else {\r\n      this.setState({\r\n        orientation: [\"vertical\", \"flex-end\", \"column\", \"center\", \"width\"],\r\n      });\r\n    }\r\n    await this.sleep(5);\r\n    this.handleOnGenerateButtonPressed();\r\n  }\r\n\r\n  ///selection sort -----------------------------------------\r\n\r\n  selectionSort = () => {\r\n    this.n = this.barsClone.length;\r\n    this.j = 1; //in if I am using preincrement so for first comparison j becomes 0\r\n    this.i = 0;\r\n    this.min_idx = 0;\r\n    this.sortIntervalId = setInterval(\r\n      this.selectionSortInnerDriven,\r\n      50 - this.state.sortingSpeed\r\n    );\r\n  };\r\n\r\n  selectionSortInnerDriven = () => {\r\n    //for n passses\r\n\r\n    if (this.i >= this.n - 1) {\r\n      clearInterval(this.sortIntervalId);\r\n\r\n      this.setState({ bars: this.barsClone, isSorting: false });\r\n    }\r\n    if (this.j < this.n) {\r\n      if (this.barsClone[this.j].width < this.barsClone[this.min_idx].width) {\r\n        this.min_idx = this.j;\r\n      }\r\n      this.j++;\r\n    } else {\r\n      const temp = this.barsClone[this.min_idx].width;\r\n      this.barsClone[this.min_idx].width = this.barsClone[this.i].width;\r\n      this.barsClone[this.i].width = temp;\r\n      this.barsClone[this.i].barsCustomClass = \"sorted_bar\";\r\n      this.setState({ bars: this.barsClone });\r\n      this.i++;\r\n      this.min_idx = this.i;\r\n      this.j = this.i + 1;\r\n    }\r\n\r\n    if (this.i < this.n && this.j < this.n) {\r\n      const tempBars = cloneDeep(this.barsClone);\r\n      tempBars[this.min_idx].barsCustomClass = \"current_bar\";\r\n      if (this.i < this.min_idx)\r\n        tempBars[this.i].barsCustomClass = \"current_bar\";\r\n      this.setState({ bars: tempBars });\r\n    }\r\n  };\r\n\r\n  handleonBarsHeightChange = (e, newvalue) => {\r\n    this.handleonBarsHeightChangeDiven(e, newvalue);\r\n  };\r\n\r\n  async handleonBarsHeightChangeDiven(e, newvalue) {\r\n    this.setState({ barsHeight: newvalue });\r\n    await this.sleep(1);\r\n    this.handleOnGenerateButtonPressed();\r\n  }\r\n\r\n  handleonBarsWidthChange = (e, newvalue) => {\r\n    this.handleonBarsWidthChangeDriven(e, newvalue);\r\n  };\r\n\r\n  async handleonBarsWidthChangeDriven(e, newvalue) {\r\n    this.setState({ barsWidth: newvalue });\r\n    await this.sleep(1);\r\n    this.handleOnGenerateButtonPressed();\r\n  }\r\n\r\n  handeleOnSpeedSliderChange = (e, newvalue) => {\r\n    if (!this.state.sortButtonIsPressed) this.handleOnGenerateButtonPressed();\r\n    this.setState({ sortingSpeed: newvalue });\r\n  };\r\n\r\n  //bubble sort =-------------------------------------------------------------\r\n  BubbleSort() {\r\n    this.n = this.barsClone.length;\r\n    this.j = -1; //in if I am using preincrement so for first comparison j becomes 0\r\n    this.i = 0;\r\n    this.sortIntervalId = setInterval(\r\n      this.BubbleSortInnerDriven,\r\n      50 - this.state.sortingSpeed\r\n    );\r\n  }\r\n\r\n  BubbleSortInnerDriven = () => {\r\n    //for n passses\r\n\r\n    if (this.i >= this.n - 1) {\r\n      clearInterval(this.sortIntervalId);\r\n    }\r\n    if (++this.j < this.n - this.i - 1) {\r\n      if (this.barsClone[this.j].width > this.barsClone[this.j + 1].width) {\r\n        // swap\r\n        let temp = this.barsClone[this.j].width;\r\n        this.barsClone[this.j].width = this.barsClone[this.j + 1].width;\r\n        this.barsClone[this.j + 1].width = temp;\r\n\r\n        //color current\r\n        const tempBars = cloneDeep(this.barsClone);\r\n        tempBars[this.j].barsCustomClass = \"current_bar\";\r\n        tempBars[this.j + 1].barsCustomClass = \"current_bar\";\r\n        this.setState({ bars: tempBars });\r\n      }\r\n    } else {\r\n      this.i++;\r\n      // if (this.i <= this.n)\r\n      this.barsClone[this.n - this.i].barsCustomClass = \"sorted_bar\";\r\n      this.setState({ bars: this.barsClone });\r\n      this.j = -1;\r\n      return;\r\n    }\r\n  };\r\n\r\n  //insertion sort ---------------------------------------------------------\r\n  insertionSort = () => {\r\n    this.n = this.barsClone.length;\r\n    this.i = 1;\r\n    this.key = this.barsClone[this.i].width;\r\n    this.j = this.i - 1;\r\n    this.sortIntervalId = setInterval(\r\n      this.insertionSortInnerDriven,\r\n      50 - this.state.sortingSpeed\r\n    );\r\n  };\r\n\r\n  insertionSortInnerDriven = () => {\r\n    if (this.i >= this.n) {\r\n      clearInterval(this.sortIntervalId);\r\n      this.setState({ bars: this.barsClone });\r\n      this.colorSortedBars();\r\n    }\r\n\r\n    if (this.j >= 0 && this.barsClone[this.j].width > this.key) {\r\n      this.barsClone[this.j + 1].width = this.barsClone[this.j].width;\r\n      const tempBars = cloneDeep(this.barsClone);\r\n      tempBars[this.j].barsCustomClass = \"current_bar\";\r\n      // tempBars[this.j + 1].barsCustomClass = \"current_bar\";\r\n      this.setState({ bars: tempBars });\r\n      this.j--;\r\n    } else {\r\n      this.barsClone[this.j + 1].width = this.key;\r\n      this.i++;\r\n      if (this.i < this.n) {\r\n        this.key = this.barsClone[this.i].width;\r\n        this.j = this.i - 1;\r\n        return;\r\n      }\r\n    }\r\n  };\r\n\r\n  sleep(ms) {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n\r\n  async quickSortHandler() {\r\n    await this.quickSort(0, this.state.totalBars - 1);\r\n    this.colorSortedBars();\r\n    this.setState({ generateButtonisActive: true, isSorting: false });\r\n  }\r\n\r\n  async quickSort(start, end) {\r\n    // Base case or terminating case\r\n    if (start >= end) {\r\n      // this.setState({ bars: this.barsClone });\r\n      // this.colorSortedBars();\r\n      return;\r\n    }\r\n\r\n    // Returns pivotIndex\r\n    let index = await this.partition(start, end);\r\n\r\n    // Recursively apply the same logic to the left and right subarrays\r\n    await this.quickSort(start, index - 1);\r\n    // await this.sleep(5);\r\n    await this.quickSort(index + 1, end);\r\n  }\r\n\r\n  async partition(start, end) {\r\n    // Taking the last element as the pivot\r\n    const pivotValue = this.barsClone[end].width;\r\n    let pivotIndex = start;\r\n    for (let i = start; i < end; i++) {\r\n      await this.sleep(50 - this.state.sortingSpeed);\r\n      if (this.barsClone[i].width < pivotValue) {\r\n        // Swapping elements\r\n        [this.barsClone[i].width, this.barsClone[pivotIndex].width] = [\r\n          this.barsClone[pivotIndex].width,\r\n          this.barsClone[i].width,\r\n        ];\r\n\r\n        const tempBars = cloneDeep(this.barsClone);\r\n        tempBars[i].barsCustomClass = \"current_bar\";\r\n        tempBars[pivotIndex].barsCustomClass = \"current_bar\";\r\n        this.setState({ bars: tempBars });\r\n        // Moving to next element\r\n        pivotIndex++;\r\n      }\r\n    }\r\n\r\n    // Putting the pivot value in the middle\r\n    [this.barsClone[pivotIndex].width, this.barsClone[end].width] = [\r\n      this.barsClone[end].width,\r\n      this.barsClone[pivotIndex].width,\r\n    ];\r\n    return pivotIndex;\r\n  }\r\n\r\n  async mergeSortHandler() {\r\n    await this.mergeSort(0, this.state.totalBars - 1);\r\n    this.colorSortedBars();\r\n    this.setState({ generateButtonisActive: true, isSorting: false });\r\n  }\r\n\r\n  async merge(l, m, r) {\r\n    let n1 = m - l + 1;\r\n    let n2 = r - m;\r\n\r\n    // Create temp arrays\r\n    let L = [];\r\n    let R = [];\r\n\r\n    // Copy data to temp arrays L[] and R[]\r\n    for (let i = 0; i < n1; i++) {\r\n      L[i] = this.barsClone[l + i].width;\r\n    }\r\n    for (let j = 0; j < n2; j++) {\r\n      R[j] = this.barsClone[m + 1 + j].width;\r\n    }\r\n\r\n    // Merge the temp arrays back into arr[l..r]\r\n\r\n    // Initial index of first subarray\r\n    let i = 0;\r\n\r\n    // Initial index of second subarray\r\n    let j = 0;\r\n\r\n    // Initial index of merged subarray\r\n    let k = l;\r\n\r\n    while (i < n1 && j < n2) {\r\n      if (L[i] <= R[j]) {\r\n        this.barsClone[k].width = L[i];\r\n        i++;\r\n      } else {\r\n        this.barsClone[k].width = R[j];\r\n        j++;\r\n      }\r\n      k++;\r\n\r\n      await this.sleep(50 - this.state.sortingSpeed);\r\n      const tempBars = cloneDeep(this.barsClone);\r\n      tempBars[k].barsCustomClass = \"current_bar\";\r\n      this.setState({ bars: tempBars });\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // L[], if there are any\r\n    while (i < n1) {\r\n      this.barsClone[k].width = L[i];\r\n      i++;\r\n      k++;\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // R[], if there are any\r\n    while (j < n2) {\r\n      this.barsClone[k].width = R[j];\r\n      j++;\r\n      k++;\r\n    }\r\n  }\r\n\r\n  async mergeSort(l, r) {\r\n    if (l >= r) {\r\n      return; //returns recursively\r\n    }\r\n    let m = parseInt((l + r - 1) / 2);\r\n    await this.mergeSort(l, m);\r\n    await this.mergeSort(m + 1, r);\r\n    await this.merge(l, m, r);\r\n  }\r\n\r\n  async heapSortHandler() {\r\n    await this.heapSort();\r\n    this.barsClone[0].barsCustomClass = \"sorted_bar\";\r\n    this.setState({\r\n      generateButtonisActive: true,\r\n      bars: this.barsClone,\r\n      isSorting: false,\r\n    });\r\n  }\r\n\r\n  async heapSort() {\r\n    let n = this.state.totalBars;\r\n\r\n    // Build heap (rearrange array)\r\n    for (let i = parseInt(n / 2 - 1); i >= 0; i--) await this.heapify(n, i);\r\n\r\n    // One by one extract an element from heap\r\n    for (let i = n - 1; i > 0; i--) {\r\n      // Move current root to end\r\n      let temp = this.barsClone[0].width;\r\n      this.barsClone[0].width = this.barsClone[i].width;\r\n      this.barsClone[i].width = temp;\r\n      this.barsClone[i].barsCustomClass = \"sorted_bar\";\r\n\r\n      // call max heapify on the reduced heap\r\n      await this.heapify(i, 0);\r\n    }\r\n  }\r\n\r\n  // To heapify a subtree rooted with node i which is\r\n  // an index in arr[]. n is size of heap\r\n  async heapify(n, i) {\r\n    await this.sleep(50 - this.state.sortingSpeed);\r\n\r\n    let largest = i; // Initialize largest as root\r\n    let l = parseInt(2 * i + 1); // left = 2*i + 1\r\n    let r = parseInt(2 * i + 2); // right = 2*i + 2\r\n\r\n    // If left child is larger than root\r\n    if (l < n && this.barsClone[l].width > this.barsClone[largest].width)\r\n      largest = l;\r\n\r\n    // If right child is larger than largest so far\r\n    if (r < n && this.barsClone[r].width > this.barsClone[largest].width)\r\n      largest = r;\r\n\r\n    // If largest is not root\r\n    if (largest != i) {\r\n      let swap = this.barsClone[i].width;\r\n      this.barsClone[i].width = this.barsClone[largest].width;\r\n      this.barsClone[largest].width = swap;\r\n      const tempBars = cloneDeep(this.barsClone);\r\n      tempBars[i].barsCustomClass = \"current_bar\";\r\n      tempBars[largest].barsCustomClass = \"current_bar\";\r\n      this.setState({ bars: tempBars });\r\n\r\n      // Recursively heapify the affected sub-tree\r\n      await this.heapify(n, largest);\r\n    }\r\n  }\r\n\r\n  getMax(n) {\r\n    let mx = this.barsClone[0].width;\r\n    for (let i = 1; i < n; i++)\r\n      if (this.barsClone[i].width > mx) mx = this.barsClone[i].width;\r\n    return mx;\r\n  }\r\n\r\n  // A function to do counting sort of this.barsClone[] according to\r\n  // the digit represented by exp.\r\n  async countSort(n, exp) {\r\n    let output = new Array(n);\r\n    for (let k = 0; k < n; ++k) output[k] = 0;\r\n\r\n    let i;\r\n\r\n    let count = new Array(n);\r\n    for (let k = 0; k < n; ++k) count[k] = 0;\r\n\r\n    // Store count of occurrences in count[]\r\n    for (i = 0; i < n; i++)\r\n      count[parseInt((this.barsClone[i].width / exp) % 10)]++;\r\n\r\n    // Change count[i] so that count[i] now contains actual\r\n    //  position of this digit in output[]\r\n    for (i = 1; i < 10; i++) count[i] += count[i - 1];\r\n\r\n    // Build the output array\r\n    for (i = n - 1; i >= 0; i--) {\r\n      output[\r\n        count[parseInt((this.barsClone[i].width / exp) % 10)] - 1\r\n      ] = this.barsClone[i].width;\r\n\r\n      await this.sleep(20);\r\n      const tempBars = cloneDeep(this.barsClone);\r\n\r\n      tempBars[\r\n        count[parseInt((this.barsClone[i].width / exp) % 10)] - 1\r\n      ].barsCustomClass = \"current_bar\";\r\n\r\n      // tempBars[i].barsCustomClass = \"current_bar\";\r\n      // tempBars[].barsCustomClass = \"current_bar\";\r\n      this.setState({ bars: tempBars });\r\n\r\n      count[parseInt(this.barsClone[i].width / exp) % 10]--;\r\n    }\r\n\r\n    // Copy the output array to arr[], so that arr[] now\r\n    // contains sorted numbers according to current digit\r\n    for (i = 0; i < n; i++) {\r\n      this.barsClone[i].width = output[i];\r\n      await this.sleep(20);\r\n      const tempBars = cloneDeep(this.barsClone);\r\n\r\n      tempBars[i].barsCustomClass = \"current_bar\";\r\n      // tempBars[].barsCustomClass = \"current_bar\";\r\n      this.setState({ bars: tempBars });\r\n    }\r\n  }\r\n\r\n  async radixsortHandler() {\r\n    await this.radixsort(this.state.totalBars);\r\n    this.colorSortedBars();\r\n    this.setState({ generateButtonisActive: true, isSorting: false });\r\n  }\r\n\r\n  // The main function to that sorts arr[] of size n using\r\n  // Radix Sort\r\n  async radixsort(n) {\r\n    // Find the maximum number to know number of digits\r\n\r\n    let m = this.getMax(n);\r\n    // Do counting sort for every digit. Note that instead\r\n    // of passing digit number, exp is passed. exp is 10^i\r\n    // where i is current digit number\r\n    for (let exp = 1; parseInt(m / exp) > 0; exp = parseInt(exp * 10)) {\r\n      await this.countSort(n, exp);\r\n      // this.setState({ bars: this.barsClone });\r\n    }\r\n  }\r\n\r\n  async shellSortHandler() {\r\n    await this.shellSort();\r\n    this.colorSortedBars();\r\n    this.setState({ generateButtonisActive: true, isSorting: false });\r\n  }\r\n\r\n  async shellSort() {\r\n    let n = this.state.totalBars;\r\n\r\n    // Start with a big gap, then reduce the gap\r\n    for (let gap = parseInt(n / 2); gap > 0; gap = parseInt(gap / 2)) {\r\n      // Do a gapped insertion sort for this gap size.\r\n      // The first gap elements a[0..gap-1] are already\r\n      // in gapped order keep adding one more element\r\n      // until the entire array is gap sorted\r\n      for (let i = gap; i < n; i += 1) {\r\n        // add a[i] to the elements that have been gap\r\n        // sorted save a[i] in temp and make a hole at\r\n        // position i\r\n        let temp = this.barsClone[i].width;\r\n\r\n        // shift earlier gap-sorted elements up until\r\n        // the correct location for a[i] is found\r\n        let j;\r\n        const tempBars = cloneDeep(this.barsClone);\r\n\r\n        for (\r\n          j = i;\r\n          j >= gap && this.barsClone[j - gap].width > temp;\r\n          j -= gap\r\n        ) {\r\n          this.barsClone[j].width = this.barsClone[j - gap].width;\r\n          await this.sleep(50 - this.state.sortingSpeed);\r\n          tempBars[j].barsCustomClass = \"current_bar\";\r\n          this.setState({ bars: tempBars });\r\n        }\r\n\r\n        // put temp (the original a[i]) in its correct\r\n        // location\r\n        await this.sleep(50 - this.state.sortingSpeed / 5);\r\n        this.barsClone[j].width = temp;\r\n        tempBars[j].barsCustomClass = \"current_bar\";\r\n        this.setState({ bars: tempBars });\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  async bucketSort() {\r\n    // 1) Create n empty buckets\r\n    // let b = [];\r\n    let ratio = this.state.totalBars * 50;\r\n    let size = this.state.totalBars;\r\n    let b = new Array(size);\r\n\r\n    // making widht smaller as to create arrays of less size\r\n    for (let i = 0; i < this.state.totalBars; i++) {\r\n      this.barsClone[i].width /= ratio;\r\n    }\r\n\r\n    // for (let i = 0; i < size; ++i) b[i] = 0;\r\n\r\n    let n = this.state.totalBars;\r\n    // 2) Put array elements in different buckets\r\n    for (let i = 0; i < size; i++) {\r\n      b[i] = new Array();\r\n    }\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      let bi = n * this.barsClone[i].width; // Index in bucket\r\n      // b[parseInt(bi)] = new Array();\r\n      await this.sleep(50 - this.state.sortingSpeed);\r\n      let tempBars = cloneDeep(this.barsClone);\r\n      for (let k = 0; k < this.state.totalBars; k++) {\r\n        tempBars[k].width = tempBars[k].width * ratio;\r\n        // if (k < index) tempBars[k].barsCustomClass = \"sorted_bar\";\r\n      }\r\n      tempBars[i].barsCustomClass = \"current_bar\";\r\n      this.setState({ bars: tempBars });\r\n\r\n      b[parseInt(bi)].push(this.barsClone[i].width);\r\n    }\r\n\r\n    // 3) Sort individual buckets\r\n    for (let i = 0; i < size; i++) b[i].sort();\r\n\r\n    // 4) Concatenate all buckets into arr[]\r\n    let index = 0;\r\n    for (let i = 0; i < size; i++) {\r\n      for (let j = 0; j < b[i].length; j++) {\r\n        this.barsClone[index++].width = b[i][j];\r\n        let tempBars = cloneDeep(this.barsClone);\r\n        for (let k = 0; k < this.state.totalBars; k++) {\r\n          tempBars[k].width = tempBars[k].width * ratio;\r\n          if (k < index) tempBars[k].barsCustomClass = \"sorted_bar\";\r\n        }\r\n        if (index < this.state.totalBars)\r\n          tempBars[index].barsCustomClass = \"current_bar\";\r\n        this.setState({ bars: tempBars });\r\n        await this.sleep(50 - this.state.sortingSpeed * 3);\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < this.state.totalBars; i++) {\r\n      this.barsClone[i].width *= ratio;\r\n    }\r\n  }\r\n\r\n  colorSortedBars = () => {\r\n    if (this.state.sortTypeSelected.value == \"insertion\")\r\n      this.i = this.state.totalBars - 2;\r\n    else this.i = this.state.totalBars - 1;\r\n    this.sortIntervalId = setInterval(() => {\r\n      if (this.i < 0) {\r\n        clearInterval(this.sortIntervalId);\r\n        this.resetEverything();\r\n      } else {\r\n        this.barsClone[this.i].barsCustomClass = \"sorted_bar\";\r\n        this.setState({ bars: this.barsClone });\r\n        this.i--;\r\n      }\r\n    }, 50 - this.state.sortingSpeed);\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        <BarsContainer\r\n          bars={this.state.bars}\r\n          OnGenerateButtonPressed={this.handleOnGenerateButtonPressed}\r\n          OnSortButtonPressed={this.handleOnSortButtonPressed}\r\n          barsPosition={this.state.barsPosition}\r\n          sortTypes={this.state.sortTypes}\r\n          onSortTypeSelected={this.handleOnSortTypeSelected}\r\n          OnOrientationPressed={this.handleOnOrientationPressed}\r\n          orientation={this.state.orientation}\r\n          barsHeight={this.state.barsHeight}\r\n          barsWidth={this.state.barsWidth}\r\n          onSpeedSliderChange={this.handeleOnSpeedSliderChange}\r\n          onbarSizeSliderChange={this.handleOnbarSizeSliderChange}\r\n          sortingSpeed={this.state.sortingSpeed}\r\n          onBarsHeightChange={this.handleonBarsHeightChange}\r\n          onBarsWidthChange={this.handleonBarsWidthChange}\r\n          windoWidth={this.state.windoWidth}\r\n          onSortingPressed={this.props.onSortingPressed}\r\n          onSearchingPressed={this.props.onSearchingPressed}\r\n          isSortingSelected={this.props.isSortingSelected}\r\n        />\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MainArea;\r\n","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Sorting\\BarsContainer.jsx",[],"D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\AlgoIndex.js",[],"D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Searching\\WorkArea.jsx",["52"],"import React, { Component } from \"react\";\r\nimport Array from \"./Array\";\r\nimport \"./home.css\";\r\nimport \"../Sorting/sorting.css\";\r\nimport \"./home.css\";\r\n\r\nclass WorkArea extends Component {\r\n  state = {\r\n    array: [],\r\n    searchKey: 0,\r\n    searchBoxStyle: \"\",\r\n    keyFound: false,\r\n    searching: false,\r\n    shouldDisplayResult: false,\r\n    arraySize: 10,\r\n    intervalTime: 5,\r\n    stopTime: 2000,\r\n    isBinarySearch: false, //make it false for linear search\r\n    isSorted: false,\r\n    middleInBinary: 0, //mid\r\n  };\r\n\r\n  constructor() {\r\n    super();\r\n    this.handlegenerateButtonPlaced();\r\n  }\r\n\r\n  handleArrayValuechange = (e) => {\r\n    this.resetArrayStyle();\r\n    const arrayConst = this.state.array.map((element) => {\r\n      if (element.index === parseInt(e.target.name)) {\r\n        if (e.target.value === \"\") element.value = 0;\r\n        //need to fix this : when the number starts from '0';\r\n        else element.value = parseInt(e.target.value, 10);\r\n      }\r\n      return element;\r\n    });\r\n\r\n    this.setState({ array: arrayConst });\r\n  };\r\n\r\n  handleArraySizeValuechange = (e) => {\r\n    let size = e.target.value;\r\n    if (size === \"\") size = \"\";\r\n    else size = parseInt(size);\r\n    this.resetArrayStyle();\r\n    this.setState({ arraySize: size });\r\n  };\r\n\r\n  handleSearchValuechange = (e) => {\r\n    let tempSearchKey;\r\n\r\n    if (e.target.value === \"\") tempSearchKey = \"\";\r\n    //need to fix this : when the number starts from '0';\r\n    else tempSearchKey = parseInt(e.target.value, 10);\r\n    this.setState({ searchKey: tempSearchKey });\r\n    this.resetArrayStyle();\r\n  };\r\n\r\n  handleOnLinearPressed = () => {\r\n    console.log(\"linear is pressed\");\r\n    this.resetArrayStyle();\r\n\r\n    this.setState({ isBinarySearch: false });\r\n  };\r\n\r\n  handleonBinaryPressed = () => {\r\n    console.log(\"biary is pressed\");\r\n    this.resetArrayStyle();\r\n\r\n    this.setState({ isBinarySearch: true });\r\n  };\r\n\r\n  handlegenerateButtonPlaced = () => {\r\n    let i = 0;\r\n    this.resetArrayStyle();\r\n\r\n    if (this.state.arraySize < 1) alert(\"We Dont't Do That Here!\");\r\n    //this will set different speeds for differet array sizes\r\n    else if (this.state.arraySize <= 100) this.setState({ intervalTime: 50 });\r\n    else if (this.state.arraySize < 500) this.setState({ intervalTime: 20 });\r\n    else this.setState({ intervalTime: 5 });\r\n\r\n    let arrayClone = [];\r\n    for (i = 0; i < this.state.arraySize; i++) {\r\n      arrayClone.push({\r\n        index: i,\r\n        value: \"\",\r\n        customClass: \"\",\r\n      });\r\n    }\r\n\r\n    this.setState({ array: arrayClone, isSorted: false });\r\n  };\r\n\r\n  handleSortButtonPressed = () => {\r\n    if (this.state.array[0].value !== \"\") {\r\n      let tempArray = [...this.state.array];\r\n      this.resetArrayStyle();\r\n      tempArray.sort(function (a, b) {\r\n        return a.value - b.value;\r\n      });\r\n      this.setState({ array: tempArray, isSorted: true });\r\n    } else {\r\n      alert(\"Fill it first\");\r\n    }\r\n  };\r\n\r\n  handlefillrandomButtonPressed = () => {\r\n    this.resetArrayStyle();\r\n    let i = 0;\r\n    let arrayClone = [];\r\n    let a = 0;\r\n    let b = 100;\r\n    for (i = 0; i < this.state.arraySize; i++) {\r\n      arrayClone.push({\r\n        index: i,\r\n        value: parseInt(Math.random() * (b - a) + a),\r\n        customClass: \"\",\r\n      });\r\n    }\r\n    this.setState({ array: arrayClone, isSorted: false });\r\n  };\r\n\r\n  handleonSearchkeypressed = () => {\r\n    let i = 0;\r\n    let intervalTime = this.state.intervalTime;\r\n    this.resetArrayStyle();\r\n\r\n    if (this.state.array.length > 0) {\r\n      //For Linear Search\r\n      if (!this.state.isBinarySearch) {\r\n        this.setState({\r\n          searchBoxStyle: \"searchBoxOnSearchActive\",\r\n          searching: true,\r\n        });\r\n        var intervalId = setInterval(\r\n          () => this.linearSearch(i++, intervalId),\r\n          intervalTime\r\n        );\r\n      }\r\n      //For Binanry Search\r\n      else {\r\n        //check for sorted\r\n        if (!this.state.isSorted) {\r\n          alert(\"Sort it first dude!\");\r\n        } else {\r\n          this.setState({\r\n            searchBoxStyle: \"searchBoxOnSearchActive\",\r\n            searching: true,\r\n          });\r\n          this.binarySearch(this.state.searchKey);\r\n        }\r\n      }\r\n    } else {\r\n      alert(\"Generate It before Searching\");\r\n    }\r\n    i = 0;\r\n  };\r\n\r\n  linearSearch = (i, intervalId) => {\r\n    let tempArray = [...this.state.array];\r\n    // if (i > 0) tempArray[i - 1].customClass = \"\"; //to make previous element reset style\r\n    this.setState({ array: tempArray });\r\n\r\n    //When found\r\n    if (this.state.array[i].value === this.state.searchKey) {\r\n      tempArray[i].customClass = \"SearchKeyFound\";\r\n      this.setState({\r\n        array: tempArray,\r\n        keyFound: true,\r\n        searching: false,\r\n        shouldDisplayResult: true,\r\n      });\r\n      clearInterval(intervalId);\r\n      // setTimeout(this.resetArrayStyle, this.state.stopTime);\r\n      return;\r\n    } else {\r\n      tempArray[i].customClass = \"searchKeyCheckedAndNotFound\"; //when checked and not equal\r\n      this.setState({ array: tempArray });\r\n    }\r\n\r\n    //Not found\r\n    if (i === this.state.array.length - 1) {\r\n      clearInterval(intervalId);\r\n      this.setState({\r\n        keyFound: false,\r\n        searching: false,\r\n        shouldDisplayResult: true,\r\n        searchBoxStyle: \"searchKeyCheckedAndNotFound\",\r\n      });\r\n      // setTimeout(this.resetArrayStyle, this.state.stopTime);\r\n    }\r\n  };\r\n\r\n  binarySearch = (key) => {\r\n    let sortedArray = [...this.state.array];\r\n    let start = 0;\r\n    let i = 0;\r\n    let end = sortedArray.length - 1;\r\n    this.setState({\r\n      middleInBinary: sortedArray[Math.floor((start + end) / 2)].value,\r\n      array: sortedArray,\r\n    });\r\n\r\n    let intervalid = setInterval(() => {\r\n      {\r\n        if (!(start <= end)) {\r\n          clearInterval(intervalid);\r\n          this.setState({\r\n            searching: false,\r\n            shouldDisplayResult: true,\r\n            keyFound: false,\r\n          });\r\n          return;\r\n        }\r\n\r\n        let middle = Math.floor((start + end) / 2);\r\n        sortedArray[middle].customClass = \"binarymiddle\";\r\n        this.setState({\r\n          middleInBinary: sortedArray[middle].value,\r\n          array: sortedArray,\r\n        });\r\n        if (sortedArray[middle].value === key) {\r\n          // found the key\r\n          sortedArray[middle].customClass = \"binarySearchMiddle\";\r\n          this.setState({\r\n            keyFound: true,\r\n            array: sortedArray,\r\n            searching: false,\r\n            shouldDisplayResult: true,\r\n          });\r\n          clearInterval(intervalid);\r\n          return;\r\n        } else if (sortedArray[middle].value < key) {\r\n          // continue searching to the right\r\n          for (i = start; i <= end; i++) {\r\n            if (i <= middle) sortedArray[i].customClass = \"binarySearchWaste\";\r\n            else sortedArray[i].customClass = \"binarySearchUse\";\r\n          }\r\n          sortedArray[middle].customClass = \"binarymiddle\";\r\n          this.setState({ array: sortedArray });\r\n          sortedArray[middle].customClass = \"binarySearchWaste\";\r\n          start = middle + 1;\r\n        } else {\r\n          // search searching to the left\r\n          for (i = start; i <= end; i++) {\r\n            if (i >= middle) sortedArray[i].customClass = \"binarySearchWaste\";\r\n            else sortedArray[i].customClass = \"binarySearchUse\";\r\n          }\r\n          sortedArray[middle].customClass = \"binarymiddle\";\r\n          this.setState({ array: sortedArray });\r\n          sortedArray[middle].customClass = \"binarySearchWaste\";\r\n          end = middle - 1;\r\n        }\r\n        if (!this.state.searching) {\r\n          this.setState({\r\n            keyFound: false,\r\n            searching: false,\r\n            shouldDisplayResult: true,\r\n            searchBoxStyle: \"searchKeyCheckedAndNotFound\",\r\n          });\r\n        }\r\n      }\r\n    }, this.state.stopTime);\r\n  };\r\n\r\n  ShowComparisation = () => {\r\n    let compareresult = \"\";\r\n    let customClass = \"\";\r\n    if (this.state.searchKey < this.state.middleInBinary) {\r\n      compareresult = \"<\";\r\n      customClass = \"searchKeyisSmall\";\r\n    } else if (this.state.searchKey > this.state.middleInBinary) {\r\n      compareresult = \">\";\r\n      customClass = \"\";\r\n      customClass = \"searchKeyisLarge\";\r\n    } else compareresult = \"=\";\r\n\r\n    if (this.state.isBinarySearch && this.state.searching) {\r\n      return (\r\n        <React.Fragment>\r\n          <span\r\n            className={\r\n              \"binary_compare arrayBox searchBox m-2 \" +\r\n              this.state.searchBoxStyle\r\n            }\r\n          >\r\n            <span className={customClass}>{this.state.searchKey}</span>\r\n\r\n            <span className={customClass}>{\" \" + compareresult + \" \"}</span>\r\n\r\n            <span className=\"binarymiddle\">{this.state.middleInBinary}</span>\r\n          </span>\r\n        </React.Fragment>\r\n      );\r\n    } else return \"\";\r\n  };\r\n\r\n  //this function will set array style to \"\"\r\n  resetArrayStyle = () => {\r\n    const tempArray = this.state.array.map((e) => {\r\n      e.customClass = \"\";\r\n      return e;\r\n    });\r\n\r\n    this.setState({\r\n      array: tempArray,\r\n      searchBoxStyle: \"\",\r\n      searching: false,\r\n      shouldDisplayResult: false,\r\n    });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Array\r\n          array={this.state.array}\r\n          searchKey={this.state.searchKey}\r\n          onArrayValueChange={this.handleArrayValuechange}\r\n          onhandleSearchValuechange={this.handleSearchValuechange}\r\n          onSearchkeypressed={this.handleonSearchkeypressed}\r\n          searchBoxStyle={this.state.searchBoxStyle}\r\n          keyFound={this.state.keyFound}\r\n          searching={this.state.searching}\r\n          shouldDisplayResult={this.state.shouldDisplayResult}\r\n          arraySize={this.state.arraySize}\r\n          onhandleArraySizeValuechange={this.handleArraySizeValuechange}\r\n          generateButtonPlaced={this.handlegenerateButtonPlaced}\r\n          onfillrandomButtonPressed={this.handlefillrandomButtonPressed}\r\n          onSortButtonPressed={this.handleSortButtonPressed}\r\n          showComparisation={this.state.showComparisation}\r\n          isBinarySearch={this.state.isBinarySearch}\r\n          handleOnLinearPressed={this.handleOnLinearPressed}\r\n          handleonBinaryPressed={this.handleonBinaryPressed}\r\n          isSortingSelected={this.props.isSortingSelected}\r\n          onSearchingPressed={this.props.onSearchingPressed}\r\n          onSortingPressed={this.props.onSortingPressed}\r\n        >\r\n          <this.ShowComparisation />\r\n        </Array>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default WorkArea;\r\n","D:\\Web Design\\React - w3schools\\myfirstreact\\src\\AlgoRhytm\\Searching\\Array.jsx",[],{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","replacedBy":"56"},{"ruleId":"53","replacedBy":"57"},{"ruleId":"55","replacedBy":"58"},{"ruleId":"59","severity":1,"message":"60","line":91,"column":39,"nodeType":"61","messageId":"62","endLine":91,"endColumn":41},{"ruleId":"63","severity":1,"message":"64","line":95,"column":13,"nodeType":"65","messageId":"66","endLine":95,"endColumn":23},{"ruleId":"59","severity":1,"message":"60","line":208,"column":42,"nodeType":"61","messageId":"62","endLine":208,"endColumn":44},{"ruleId":"59","severity":1,"message":"60","line":272,"column":33,"nodeType":"61","messageId":"62","endLine":272,"endColumn":35},{"ruleId":"59","severity":1,"message":"60","line":281,"column":37,"nodeType":"61","messageId":"62","endLine":281,"endColumn":39},{"ruleId":"59","severity":1,"message":"60","line":301,"column":35,"nodeType":"61","messageId":"62","endLine":301,"endColumn":37},{"ruleId":"59","severity":1,"message":"67","line":648,"column":17,"nodeType":"61","messageId":"62","endLine":648,"endColumn":19},{"ruleId":"68","severity":1,"message":"69","line":807,"column":14,"nodeType":"70","messageId":"71","endLine":807,"endColumn":25},{"ruleId":"59","severity":1,"message":"60","line":851,"column":43,"nodeType":"61","messageId":"62","endLine":851,"endColumn":45},{"ruleId":"72","severity":1,"message":"73","line":207,"column":7,"nodeType":"74","messageId":"75","endLine":264,"endColumn":8},"no-native-reassign",["76"],"no-negated-in-lhs",["77"],["76"],["77"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'rightSpace' is assigned a value but never used.","Identifier","unusedVar","Expected '!==' and instead saw '!='.","no-array-constructor","The array literal notation [] is preferable.","NewExpression","preferLiteral","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","no-global-assign","no-unsafe-negation"]